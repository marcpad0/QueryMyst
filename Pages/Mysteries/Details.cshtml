@page "{id:int}"
@model QueryMyst.Pages.Mysteries.DetailsModel // Make sure this namespace is correct
@{
    ViewData["Title"] = $"Mystery: {Model.Mystery?.Title}";
}

<div class="container-fluid mt-4">
    @if (Model.Mystery != null && Model.Mystery.Details != null)
    {
        <div class="row">
            <!-- Mystery Header -->
            <div class="col-12 mb-4">
                <div class="card shadow border-0 bg-gradient-primary text-white">
                    <div class="card-body py-3">
                        <div class="d-flex align-items-center">
                            <div class="mystery-icon me-3">
                                @Html.Raw(Model.Mystery.Icon ?? "<i class='bi bi-question-diamond'></i>")
                            </div>
                            <div>
                                <h2 class="mb-0">@Model.Mystery.Title</h2>
                                <div class="mt-2">
                                    <span class="badge @Model.Mystery.DifficultyClass me-2">@Model.Mystery.Difficulty</span>
                                    <span class="badge bg-secondary me-2">@Model.Mystery.Category</span>
                                    @if (Model.Mystery.RequiredSkills != null && Model.Mystery.RequiredSkills.Any())
                                    {
                                        @foreach (var skill in Model.Mystery.RequiredSkills)
                                        {
                                            <span class="badge bg-light text-dark skill-tag me-1">@skill</span>
                                        }
                                    }
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Left Column: Mystery Info -->
            <div class="col-lg-5">
                <div class="card shadow-sm border-0 rounded-4 mb-4 h-100">
                    <div class="card-header bg-gradient-primary text-white rounded-top-4">
                        <h4 class="mb-0"><i class="bi bi-book-half me-2"></i> Case File</h4>
                    </div>
                    <div class="card-body d-flex flex-column">
                        <h5 class="mt-2 mb-3 text-primary"><i class="bi bi-info-circle me-2"></i>Description</h5>
                        <p class="lead">@Model.Mystery.Details.FullDescription</p>

                        <!-- Hints and Clues -->
                        <div class="accordion mt-4" id="hintsAccordion">
                           <div class="accordion-item border-0 shadow-sm mb-3 rounded-3">
                                <h2 class="accordion-header" id="hintsHeading">
                                    <button class="accordion-button collapsed rounded-3" type="button"
                                        data-bs-toggle="collapse" data-bs-target="#collapseHints" aria-expanded="false"
                                        aria-controls="collapseHints">
                                        <i class="bi bi-lightbulb-fill me-2 text-warning"></i> Need a Hint?
                                    </button>
                                </h2>
                                <div id="collapseHints" class="accordion-collapse collapse" aria-labelledby="hintsHeading">
                                    <div class="accordion-body">
                                        @if (!string.IsNullOrWhiteSpace(Model.Mystery.Details.HintText))
                                        {
                                            <p class="hint-text">@Model.Mystery.Details.HintText</p>
                                        }
                                        else
                                        {
                                            <p class="text-muted">No hints available for this mystery.</p>
                                        }
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item border-0 shadow-sm rounded-3">
                                <h2 class="accordion-header" id="cluesHeading">
                                    <button class="accordion-button collapsed rounded-3" type="button"
                                        data-bs-toggle="collapse" data-bs-target="#collapseClues" aria-expanded="false"
                                        aria-controls="collapseClues">
                                        <i class="bi bi-signpost-split me-2 text-info"></i> False Clues
                                    </button>
                                </h2>
                                <div id="collapseClues" class="accordion-collapse collapse" aria-labelledby="cluesHeading">
                                    <div class="accordion-body">
                                        @if (!string.IsNullOrWhiteSpace(Model.Mystery.Details.FalseClues))
                                        {
                                            <p class="clue-text">@Model.Mystery.Details.FalseClues</p>
                                        }
                                        else
                                        {
                                            <p class="text-muted">No false clues listed for this mystery.</p>
                                        }
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Database Schema Visualization -->
                        <h5 class="mt-4 mb-3 text-primary"><i class="bi bi-diagram-3-fill me-2"></i>Database Schema</h5>
                         <ul class="nav nav-tabs mb-3" id="schemaViews" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="visual-tab" data-bs-toggle="tab"
                                    data-bs-target="#visual-schema" type="button" role="tab" aria-selected="true">
                                    <i class="bi bi-eye-fill me-1"></i> Visual
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="code-tab" data-bs-toggle="tab" data-bs-target="#code-schema"
                                    type="button" role="tab" aria-selected="false">
                                    <i class="bi bi-code-slash me-1"></i> SQL Code
                                </button>
                            </li>
                        </ul>
                        <div class="tab-content flex-grow-1" id="schemaViewsContent">
                            <div class="tab-pane fade show active" id="visual-schema" role="tabpanel">
                                <!-- Container for the NEW enhanced interactive schema visualization -->
                                <div class="schema-enhanced-container">
                                    <div class="schema-controls">
                                        <button type="button" id="schema-zoom-in" class="btn btn-sm btn-outline-primary" title="Zoom In">
                                            <i class="bi bi-zoom-in"></i>
                                        </button>
                                        <button type="button" id="schema-zoom-out" class="btn btn-sm btn-outline-primary" title="Zoom Out">
                                            <i class="bi bi-zoom-out"></i>
                                        </button>
                                        <button type="button" id="schema-reset" class="btn btn-sm btn-outline-secondary" title="Reset View">
                                            <i class="bi bi-arrows-fullscreen"></i>
                                        </button>
                                    </div>
                                    <div id="schema-viewport" class="schema-viewport">
                                        <div id="schema-workspace" class="schema-workspace">
                                            <!-- Interactive visualization will be rendered here -->
                                        </div>
                                    </div>
                                    <div class="schema-info small text-muted mt-2">
                                        <i class="bi bi-info-circle me-1"></i> Drag tables to reposition. Use mouse wheel or buttons to zoom. Click and drag empty space to pan.
                                    </div>
                                </div>
                            </div>
                            <div class="tab-pane fade" id="code-schema" role="tabpanel">
                                <!-- Keep the code tab unchanged -->
                                <h6 class="mt-2 mb-2">Schema Definition:</h6>
                                <pre><code class="language-sql bg-light border rounded p-2">@Model.Mystery.Details.DatabaseSchema</code></pre>
                                <h6 class="mt-4 mb-2">Sample Data:</h6>
                                <pre><code class="language-sql bg-light border rounded p-2">@Model.Mystery.Details.SampleData</code></pre>
                            </div>
                        </div>

                        <!-- Notes Section -->
                        <div class="mt-auto pt-4"> <!-- Push notes to bottom -->
                            <div class="d-flex justify-content-between align-items-center">
                                <h5 class="text-primary mb-0"><i class="bi bi-pencil-square me-2"></i>Your Notes</h5>
                                <span id="notes-saved" class="saved-indicator"><i class="bi bi-check-circle"></i>
                                    Saved</span>
                            </div>
                            <div class="form-floating mt-2">
                                <textarea class="form-control" id="userNotes" style="height: 100px"
                                placeholder="Your notes about this mystery"></textarea>
                                <label for="userNotes">Take notes about your approach...</label>
                            </div>
                            <div class="d-flex justify-content-end mt-2">
                                <button id="clearNotes" class="btn btn-outline-secondary btn-sm me-2" title="Clear Notes">
                                    <i class="bi bi-trash"></i> Clear
                                </button>
                                <button id="saveNotes" class="btn btn-primary btn-sm" title="Save Notes Now">
                                    <i class="bi bi-save"></i> Save Notes
                                </button>
                            </div>
                        </div>
                    </div> <!-- End Card Body -->
                </div> <!-- End Card -->
            </div> <!-- End Left Column -->

            <!-- Right Column: SQL Editor & Results -->
            <div class="col-lg-7">
                <div class="d-flex flex-column h-100">
                     <!-- SQL Editor Card -->
                    <div class="card shadow-sm border-0 rounded-4 mb-4 @(Model.IsPost ? "flex-grow-0" : "flex-grow-1")">
                        <div class="card-header bg-gradient-secondary text-white rounded-top-4">
                            <div class="d-flex justify-content-between align-items-center">
                                <h5 class="mb-0"><span class="editor-header-sparkle"><i class="bi bi-terminal me-2"></i> SQL Query Editor</span></h5>
                                <button class="btn btn-sm btn-outline-light" id="toggle-fullscreen" title="Toggle Fullscreen Editor">
                                    <i class="bi bi-arrows-fullscreen"></i>
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <form method="post">
                                <div asp-validation-summary="ModelOnly" class="text-danger mb-3 small"></div>
                                <div class="mb-3">
                                    <div class="editor-toolbar bg-light p-1 rounded-top border d-flex flex-wrap gap-1">
                                        <button type="button" class="btn btn-sm btn-outline-secondary template-btn" data-template="SELECT * FROM ">SELECT *</button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary template-btn" data-template="SELECT COUNT(*) FROM ">COUNT(*)</button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary template-btn" data-template="WHERE ">WHERE</button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary template-btn" data-template="JOIN ">JOIN</button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary template-btn" data-template="ON ">ON</button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary template-btn" data-template="GROUP BY ">GROUP BY</button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary template-btn" data-template="ORDER BY ">ORDER BY</button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary template-btn" data-template="LIMIT ">LIMIT</button>
                                    </div>
                                    <textarea asp-for="UserQuery" class="form-control rounded-0 rounded-bottom auto-resize"
                                        id="sqlQueryArea" rows="8"
                                        placeholder="-- Enter your SQL query here...
SELECT CustomerID, FirstName, Email FROM Customers WHERE RegistrationDate > '2023-01-01';"
                                        aria-label="SQL Query Input Area"></textarea>
                                    <span asp-validation-for="UserQuery" class="text-danger small"></span>
                                </div>
                                <div class="d-flex align-items-center">
                                    <button type="submit" class="btn btn-success px-4">
                                        <i class="bi bi-play-fill me-1"></i> Run Query
                                    </button>
                                    <div class="ms-auto">
                                        <div class="form-check form-check-inline">
                                            <input class="form-check-input" type="checkbox" id="autoFormatCheck">
                                            <label class="form-check-label small" for="autoFormatCheck">Auto-format</label>
                                        </div>
                                    </div>
                                </div>
                            </form>
                        </div>
                    </div>

                    <!-- Results Area (Only shows after Post) -->
                    @if (Model.IsPost)
                    {
                        <div class="card shadow-sm border-0 rounded-4 flex-grow-1"> <!-- Results take remaining space -->
                            <div class="card-header @(Model.IsCorrectSolution ? "bg-gradient-success" : (string.IsNullOrEmpty(Model.ErrorMessage) ? "bg-gradient-info" : "bg-gradient-danger")) text-white rounded-top-4">
                                <h5 class="mb-0">
                                    @if (Model.IsCorrectSolution)
                                    {
                                        <i class="bi bi-check-circle-fill me-2"></i> <span>Correct Solution!</span>
                                    }
                                    else if (!string.IsNullOrEmpty(Model.ErrorMessage))
                                    {
                                        <i class="bi bi-exclamation-triangle-fill me-2"></i> <span>Query Error</span>
                                    }
                                    else
                                    {
                                        <i class="bi bi-search me-2"></i> <span>Query Results</span>
                                    }
                                </h5>
                            </div>
                            <div class="card-body overflow-auto"> <!-- Make results scrollable -->
                                @if (Model.IsCorrectSolution)
                                {
                                    <div class="alert alert-success border-0 shadow-sm" role="alert">
                                        <div class="d-flex align-items-center">
                                            <div class="me-3 fs-2"><i class="bi bi-trophy-fill"></i></div>
                                            <div>
                                                <h5 class="alert-heading">Congratulations!</h5>
                                                <p class="mb-0">You solved the mystery correctly. Well done, detective!</p>
                                            </div>
                                        </div>
                                    </div>
                                }
                                @if (!string.IsNullOrEmpty(Model.QueryResult))
                                {
                                    <div class="result-container">
                                        <h6 class="mb-2 text-muted">Your Query Results:</h6>
                                        <!-- Formatted results will appear here -->
                                        <div id="formatted-results" class="table-responsive">
                                            <div class="text-center text-muted p-3">Formatting results...</div>
                                        </div>
                                        <!-- Raw results are hidden but used by JS -->
                                        <pre class="d-none"><code class="result" id="raw-results">@Model.QueryResult</code></pre>
                                    </div>
                                }
                                @if (!string.IsNullOrEmpty(Model.ErrorMessage))
                                {
                                    <div class="alert alert-danger shadow-sm border-0" role="alert">
                                        <h6 class="mb-1"><i class="bi bi-bug-fill me-2"></i>Error Details:</h6>
                                        <pre class="mb-0"><code class="error small">@Model.ErrorMessage</code></pre>
                                    </div>
                                }
                                @if (!Model.IsCorrectSolution && string.IsNullOrEmpty(Model.QueryResult) && string.IsNullOrEmpty(Model.ErrorMessage))
                                {
                                     <p class="text-muted text-center mt-3">Your query executed successfully but returned no results.</p>
                                }
                            </div> <!-- End Results Card Body -->
                        </div> <!-- End Results Card -->
                    }
                 </div> <!-- End Right Column Flex Container -->
            </div> <!-- End Right Column -->
        </div> <!-- End Row -->
    }
    else
    {
        <div class="alert alert-danger shadow-sm border-0" role="alert">
            <h5><i class="bi bi-exclamation-circle me-2"></i> Mystery not found</h5>
            <p>The mystery you're looking for doesn't exist or critical details are missing.</p>
            <a href="/Mysteries" class="btn btn-outline-danger">Return to Mysteries List</a>
        </div>
    }
</div>

@section Scripts {
    @{
        await Html.RenderPartialAsync("_ValidationScriptsPartial");
    }

    <!-- Add Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>

    <!-- Add CodeMirror for enhanced SQL editor -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/mdn-like.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/sql/sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>

    <style>
        /* Base card styling */
        .card {
            transition: all 0.2s ease;
            overflow: hidden;
            /* margin-bottom: 1rem !important; Let flexbox handle spacing */
        }

        .mystery-icon i {
            font-size: 2.5rem;
            background: rgba(255, 255, 255, 0.2);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rounded-4 { border-radius: 0.7rem !important; }
        .rounded-top-4 { border-top-left-radius: 0.7rem !important; border-top-right-radius: 0.7rem !important; }

        /* Custom gradients */
        .bg-gradient-primary { background: linear-gradient(135deg, #6259ca, #4e36e2); }
        .bg-gradient-secondary { background: linear-gradient(135deg, #5c636a, #343a40); }
        .bg-gradient-success { background: linear-gradient(135deg, #1cae59, #0ca750); }
        .bg-gradient-info { background: linear-gradient(135deg, #17a2b8, #0f8999); }
        .bg-gradient-danger { background: linear-gradient(135deg, #dc3545, #b02a37); }

        /* Notes feature */
        #userNotes { background-color: #fffde7; border-color: #fff9c4; font-family: 'Segoe UI', Roboto, sans-serif; }
        #userNotes:focus { box-shadow: 0 0 0 0.25rem rgba(255, 235, 59, 0.25); border-color: #ffd600; }
        .saved-indicator { color: #198754; opacity: 0; transition: opacity 0.5s ease; font-size: 0.9rem; }
        .saved-indicator.visible { opacity: 1; }

        /* Editor styling */
        #sqlQueryArea { 
            font-family: 'Consolas', 'Courier New', monospace; 
            font-size: 0.95rem; 
            tab-size: 4; 
            min-height: 150px; 
            max-height: 500px; /* Add maximum height */
            resize: vertical; 
            overflow-y: hidden; /* Hide scrollbar during auto-resize */
            transition: height 0.2s ease; /* Smooth height transition */
        }
        
        /* Auto-resize textarea styles */
        .auto-resize {
            height: auto;
            overflow-y: hidden;
        }

        /* Results table styling */
        .query-results-table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; box-shadow: 0 2px 3px rgba(0, 0, 0, 0.05); font-size: 0.9rem; }
        .query-results-table thead { background-color: #4e36e2; color: white; position: sticky; top: 0; z-index: 1; } /* Sticky header */
        .query-results-table th, .query-results-table td { padding: 0.6rem 0.8rem; border: 1px solid #dee2e6; text-align: left; white-space: nowrap; }
        .query-results-table tbody tr:nth-child(even) { background-color: #f8fafc; }
        .query-results-table tbody tr:hover { background-color: #e9ecef; }
        .query-results-table td .text-muted { font-style: italic; color: #999 !important;}

        /* Skill tags */
        .skill-tag { font-size: 0.75rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; }

        /* Fullscreen editor */
        .editor-fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1050; background: white; padding: 1rem; overflow-y: auto; display: flex; flex-direction: column; }
        .editor-fullscreen .card-header { border-radius: 0 !important; }
        .editor-fullscreen .card-body { flex-grow: 1; display: flex; flex-direction: column; }
        .editor-fullscreen form { flex-grow: 1; display: flex; flex-direction: column; }
        .editor-fullscreen form > div:first-of-type { flex-grow: 1; display: flex; flex-direction: column; } /* Make textarea container grow */
        .editor-fullscreen #sqlQueryArea { flex-grow: 1; height: auto !important; /* Let flex grow determine height */ min-height: 300px; } /* Remove fixed height */

        /* Code blocks */
        pre code { display: block; padding: 0.75rem 1rem; border-radius: 0.3rem; font-size: 0.9rem; white-space: pre-wrap; word-break: break-all; }
        pre code.error { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; }
        .result-container { animation: fadeIn 0.5s ease; }
        @@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- FIXES FOR COLUMN LAYOUT & SCROLLING --- */
        .row { display: flex; flex-wrap: wrap; }
        .col-lg-5, .col-lg-7 { display: flex; flex-direction: column; }
        .h-100 { height: 100%; }
        .flex-grow-1 { flex-grow: 1 !important; }
        .flex-grow-0 { flex-grow: 0 !important; }
        .overflow-auto { overflow: auto; }
        .card-body { overflow: auto; } /* Default overflow auto for card bodies */

        /* --- ENHANCED INTERACTIVE Schema Visualization --- */
        .schema-enhanced-container {
            position: relative;
            border: 1px solid #e0e0e0;
            border-radius: 0.75rem;
            background-color: #f8f9fa;
            background-image: 
                radial-gradient(circle, rgba(200, 200, 200, 0.1) 1px, transparent 1px),
                radial-gradient(circle, rgba(200, 200, 200, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            overflow: hidden;
            min-height: 400px;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
        }

        .schema-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 5px;
            background-color: rgba(255,255,255,0.8);
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .schema-viewport {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
            min-height: 350px;
            width: 100%;
        }

        .schema-viewport.grabbing {
            cursor: grabbing;
        }

        .schema-workspace {
            position: absolute;
            transform-origin: 0 0;
            min-width: 100%;
            min-height: 100%;
            transition: transform 0.1s ease;
        }

        .schema-table {
            background-color: #ffffff;
            border-radius: 0.8rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            width: 260px;
            display: flex;
            flex-direction: column;
            cursor: move;
            transition: box-shadow 0.2s ease, transform 0.1s ease;
            user-select: none;
            position: absolute; /* For drag positioning */
        }

        .schema-table.dragging {
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            transform: scale(1.02);
        }

        .schema-table:hover {
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .schema-table-header {
            background-image: linear-gradient(135deg, #6366F1, #8B5CF6, #3B82F6);
            color: white;
            padding: 0.7rem 1rem;
            border-top-left-radius: 0.8rem;
            border-top-right-radius: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            font-size: 1.05rem;
        }

        .schema-table-header i {
            margin-right: 0.6rem;
            font-size: 1.1rem;
        }

        .schema-table-body {
            padding: 0.3rem;
            flex-grow: 1;
            overflow-y: auto;
            max-height: 250px;
        }

        .schema-column {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.7rem;
            border-bottom: 1px solid #f0f3f7;
            font-size: 0.85rem;
            transition: background-color 0.15s ease;
        }

        .schema-column.pk-column {
            background-color: #FEF3C7;
        }

        .schema-column.fk-column {
            background-color: #DBEAFE;
        }

        .schema-info {
            padding: 5px 10px;
            text-align: center;
            background-color: rgba(255,255,255,0.8);
            border-top: 1px solid #eee;
        }

        /* SVG connector styling */
        .relationship-line {
            stroke: rgba(100, 116, 139, 0.6);
            stroke-width: 2;
            stroke-dasharray: 5 3;
            pointer-events: none; /* prevent lines from blocking mouse events */
        }

        .relationship-arrow {
            fill: rgba(100, 116, 139, 0.6);
        }

        /* Cute SQL Editor Theme */
        .CodeMirror {
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
            height: auto;
            min-height: 150px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            transition: box-shadow 0.3s ease;
        }

        .CodeMirror:focus-within {
            box-shadow: 0 2px 12px rgba(98, 89, 202, 0.2);
            border-color: #9c96e4;
        }

        .CodeMirror-wrap {
            padding: 4px 0;
        }

        /* Customized SQL keyword colors */
        .cm-s-cute-sql .cm-keyword {
            color: #ff79c6; /* Pink for keywords */
            font-weight: 700;
        }
        
        .cm-s-cute-sql .cm-operator {
            color: #50fa7b; /* Green for operators */
        }
        
        .cm-s-cute-sql .cm-number {
            color: #bd93f9; /* Purple for numbers */
        }
        
        .cm-s-cute-sql .cm-string {
            color: #f1fa8c; /* Yellow for strings */
        }
        
        .cm-s-cute-sql .cm-comment {
            color: #6272a4; /* Blue-gray for comments */
            font-style: italic;
        }

        .cm-s-cute-sql .cm-def {
            color: #50fa7b; /* Green for definitions */
        }

        .cm-s-cute-sql .cm-variable {
            color: #f8f8f2; /* White-ish for variables */
        }

        .cm-s-cute-sql .cm-builtin {
            color: #ff79c6; /* Pink for built-in functions */
            font-weight: bold;
        }

        .cm-s-cute-sql .cm-atom {
            color: #bd93f9; /* Purple for atoms/constants */
        }

        /* Custom background and text */
        .cm-s-cute-sql.CodeMirror {
            background-color: #282a36; /* Dark background */
            color: #f8f8f2; /* Light text */
        }

        .cm-s-cute-sql .CodeMirror-cursor {
            border-left: 2px solid #f8f8f2; /* Cursor color */
        }

        .cm-s-cute-sql .CodeMirror-selected {
            background: rgba(255, 255, 255, 0.1); /* Selection background */
        }
        
        /* Add cute little sparkles to the editor header */
        .editor-header-sparkle {
            position: relative;
            display: inline-block;
        }
        
        .editor-header-sparkle::before,
        .editor-header-sparkle::after {
            content: "✨";
            font-size: 0.8rem;
            position: absolute;
        }
        
        .editor-header-sparkle::before {
            top: -0.5rem;
            left: -0.25rem;
            animation: sparkle 2s infinite;
        }
        
        .editor-header-sparkle::after {
            top: -0.5rem;
            right: -0.25rem;
            animation: sparkle 2s 1s infinite;
        }
        
        @@keyframes sparkle {
            0%, 100% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        /* Template buttons styling */
        .template-btn {
            transition: all 0.2s ease;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .template-btn:hover {
            background-color: #6259ca; 
            border-color: #6259ca;
            color: white;
            transform: translateY(-2px);
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize syntax highlighting for SQL blocks
            document.querySelectorAll('pre code.language-sql').forEach((block) => {
                hljs.highlightElement(block);
            });

            // --- Interactive Schema Visualization ---
            function visualizeSchema() {
                // Get container elements
                const viewport = document.getElementById('schema-viewport');
                const workspace = document.getElementById('schema-workspace');
                
                if (!viewport || !workspace) {
                    console.error("Schema viewport or workspace not found");
                    return;
                }
                
                // Clear previous content
                workspace.innerHTML = '';
                
                // Create SVG element for relationships
                const svg = document.createElementNS(SVG_NAMESPACE, "svg");
                svg.setAttribute('class', 'schema-relationships');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '0';
                workspace.appendChild(svg);
                
                try {
                    const schemaDataElement = document.querySelector('#code-schema code.language-sql');
                    const schemaText = schemaDataElement ? schemaDataElement.textContent : '';

                    if (!schemaText) {
                        throw new Error("Schema text could not be retrieved.");
                    }

                    const tables = parseSchemaFromSQL(schemaText);

                    if (tables.length === 0) {
                        workspace.innerHTML = '<div class="alert alert-info text-center">No tables found or could not parse schema.</div>';
                        return;
                    }

                    // Calculate initial layout
                    const viewportWidth = viewport.clientWidth;
                    const viewportHeight = viewport.clientHeight;
                    const containerWidth = Math.max(1200, viewportWidth * 1.5); // Make workspace larger than viewport
                    const layout = calculateTableLayout(tables, containerWidth);
                    
                    // Set workspace initial size based on table positions
                    let maxX = 0, maxY = 0;
                    Object.values(layout.positions).forEach(pos => {
                        maxX = Math.max(maxX, pos.x + TABLE_WIDTH);
                        maxY = Math.max(maxY, pos.y + TABLE_HEIGHT);
                    });
                    
                    workspace.style.width = `${maxX + 100}px`;
                    workspace.style.height = `${maxY + 100}px`;

                    // Create table elements with absolute positioning
                    const tableElements = {};
                    tables.forEach((table) => {
                        const tablePosition = layout.positions[table.name] || { x: 0, y: 0 };
                        const tableElement = createTableElement(table, tablePosition);
                        tableElements[table.name] = tableElement;
                        workspace.appendChild(tableElement);
                    });

                    // Draw relationship connections
                    drawRelationships(svg, layout.relationships, tableElements);

                    // Initialize pan and zoom
                    initPanZoom(viewport, workspace);
                    
                    // Initialize drag functionality for tables
                    Object.values(tableElements).forEach(tableElement => {
                        initDraggable(tableElement, svg, layout.relationships, tableElements);
                    });
                    
                    // Add zoom controls
                    initZoomControls(viewport, workspace);
                    
                    // Center the workspace initially
                    centerWorkspace(viewport, workspace);
                    
                } catch (error) {
                    console.error('Error visualizing schema:', error);
                    workspace.innerHTML = `<div class="alert alert-warning">Error rendering schema: ${error.message}</div>`;
                }
            }

            // Create a table element with its columns
            function createTableElement(table, position) {
                const tableElement = document.createElement('div');
                tableElement.className = 'schema-table';
                tableElement.id = `schema-table-${table.name}`;
                tableElement.style.left = `${position.x}px`;
                tableElement.style.top = `${position.y}px`;
                tableElement.dataset.name = table.name;
                
                // Choose icon based on table name
                let tableIcon = 'bi-table';
                if (table.name.toLowerCase().includes('employee')) tableIcon = 'bi-people-fill';
                if (table.name.toLowerCase().includes('computer')) tableIcon = 'bi-pc-display';
                if (table.name.toLowerCase().includes('authentication')) tableIcon = 'bi-shield-lock';
                if (table.name.toLowerCase().includes('network')) tableIcon = 'bi-diagram-3';
                if (table.name.toLowerCase().includes('log')) tableIcon = 'bi-journal-text';
                if (table.name.toLowerCase().includes('ip') || table.name.toLowerCase().includes('external')) tableIcon = 'bi-globe';
                if (table.name.toLowerCase().includes('file')) tableIcon = 'bi-file-earmark';
                
                let tableHtml = `
                    <div class="schema-table-header">
                        <div><i class="bi ${tableIcon}"></i>${table.name}</div>
                        <div class="table-badge">${table.columns.length}</div>
                    </div>
                    <div class="schema-table-body">`;
                
                // Add columns
                table.columns.forEach(column => {
                    let columnClass = 'schema-column';
                    let pkIcon = '';
                    let fkIcon = '';
                    let title = '';
                    
                    if (column.isPrimaryKey) {
                        pkIcon = '<i class="bi bi-key-fill text-warning me-1"></i>';
                        columnClass += ' pk-column';
                        title = 'Primary Key';
                    }
                    if (column.isForeignKey) {
                        fkIcon = '<i class="bi bi-link-45deg text-primary me-1"></i>';
                        columnClass += ' fk-column';
                        title += (title ? ' & ' : '') + `Foreign Key (→ ${column.referencesTable || 'Unknown'})`;
                    }
                    
                    tableHtml += `
                        <div class="${columnClass}" title="${title}">
                            <div class="schema-col-name">
                                ${pkIcon}${fkIcon}${column.name}
                            </div>
                            <div class="schema-col-type">${column.type}</div>
                        </div>`;
                });
                
                tableHtml += '</div>'; // Close table body
                tableElement.innerHTML = tableHtml;
                
                return tableElement;
            }

            // Draw relationship lines between tables
            function drawRelationships(svg, relationships, tableElements) {
                if (!svg || !relationships) return;
                
                // Clear previous lines
                while (svg.firstChild) {
                    svg.removeChild(svg.firstChild);
                }
                
                // Group relationships by source-target pair
                const relationshipGroups = {};
                relationships.forEach(rel => {
                    const key = `${rel.from}->${rel.to}`;
                    if (!relationshipGroups[key]) relationshipGroups[key] = [];
                    relationshipGroups[key].push(rel);
                });
                
                // Create each relationship line
                Object.entries(relationshipGroups).forEach(([key, relations]) => {
                    const [fromTable, toTable] = key.split('->');
                    
                    const fromElement = tableElements[fromTable];
                    const toElement = tableElements[toTable];
                    
                    if (!fromElement || !toElement) return;
                    
                    // Get element positions for connection points
                    const fromRect = fromElement.getBoundingClientRect();
                    const toRect = toElement.getBoundingClientRect();
                    const fromBox = { 
                        x: parseFloat(fromElement.style.left), 
                        y: parseFloat(fromElement.style.top),
                        width: fromElement.offsetWidth,
                        height: fromElement.offsetHeight
                    };
                    const toBox = { 
                        x: parseFloat(toElement.style.left), 
                        y: parseFloat(toElement.style.top),
                        width: toElement.offsetWidth,
                        height: toElement.offsetHeight
                    };
                    
                    // Find connecting points on table edges
                    const fromPoint = findConnectionPoint(fromBox, toBox);
                    const toPoint = findConnectionPoint(toBox, fromBox);
                    
                    // Create the path with cubic bezier curve
                    const path = document.createElementNS(SVG_NAMESPACE, "path");
                    
                    // Calculate control points for curve (better path)
                    const dx = toPoint.x - fromPoint.x;
                    const dy = toPoint.y - fromPoint.y;
                    const midX = fromPoint.x + dx * 0.5;
                    const midY = fromPoint.y + dy * 0.5;
                    
                    // Adjust control points for smoother curves
                    const controlLen = Math.min(Math.abs(dx), Math.abs(dy)) * 0.5 + 50;
                    const controlPoints = calculateControlPoints(fromPoint, toPoint, controlLen);
                    
                    // Draw the bezier curve path
                    const pathData = `M ${fromPoint.x} ${fromPoint.y} C ${controlPoints.cp1x} ${controlPoints.cp1y}, ${controlPoints.cp2x} ${controlPoints.cp2y}, ${toPoint.x} ${toPoint.y}`;
                    
                    path.setAttribute("d", pathData);
                    path.setAttribute("class", "relationship-line");
                    path.setAttribute("data-from", fromTable);
                    path.setAttribute("data-to", toTable);
                    
                    // Add arrow marker
                    const markerId = `arrow-${fromTable.replace(/\s+/g, '')}-${toTable.replace(/\s+/g, '')}`;
                    addArrowMarker(svg, markerId);
                    path.setAttribute("marker-end", `url(#${markerId})`);
                    
                    // Add tooltip
                    const relationshipTitle = document.createElementNS(SVG_NAMESPACE, "title");
                    const relInfo = relations.map(r => `${r.fromColumn} → ${r.toColumn}`).join(', ');
                    relationshipTitle.textContent = `${fromTable} → ${toTable} (${relInfo})`;
                    path.appendChild(relationshipTitle);
                    
                    svg.appendChild(path);
                    
                    // Add badge showing multiple relationships if needed
                    if (relations.length > 1) {
                        const textBg = document.createElementNS(SVG_NAMESPACE, "circle");
                        const midPoint = {
                            x: midX, 
                            y: midY
                        };
                        
                        textBg.setAttribute("cx", midPoint.x);
                        textBg.setAttribute("cy", midPoint.y);
                        textBg.setAttribute("r", 12);
                        textBg.setAttribute("fill", "#6466f1");
                        svg.appendChild(textBg);
                        
                        const textElement = document.createElementNS(SVG_NAMESPACE, "text");
                        textElement.setAttribute("x", midPoint.x);
                        textElement.setAttribute("y", midPoint.y + 4);
                        textElement.setAttribute("text-anchor", "middle");
                        textElement.setAttribute("font-size", "10px");
                        textElement.setAttribute("fill", "white");
                        textElement.textContent = relations.length;
                        svg.appendChild(textElement);
                    }
                });
            }

            // Find connection points between two boxes
            function findConnectionPoint(fromBox, toBox) {
                // Find center points
                const fromCenter = { x: fromBox.x + fromBox.width/2, y: fromBox.y + fromBox.height/2 };
                const toCenter = { x: toBox.x + toBox.width/2, y: toBox.y + toBox.height/2 };
                
                // Determine connection edge based on relative positions
                let x, y;
                
                // Horizontal positioning
                if (fromCenter.x < toCenter.x) { // from is to the left of to
                    x = fromBox.x + fromBox.width;
                } else { // from is to the right of to
                    x = fromBox.x;
                }
                
                // Vertical positioning
                if (fromCenter.y < toCenter.y) { // from is above to
                    y = fromBox.y + fromBox.height;
                } else { // from is below to
                    y = fromBox.y;
                }
                
                // If boxes are more aligned horizontally than vertically, connect on sides
                if (Math.abs(fromCenter.x - toCenter.x) > Math.abs(fromCenter.y - toCenter.y)) {
                    y = fromBox.y + fromBox.height/2;
                } else {
                    x = fromBox.x + fromBox.width/2;
                }
                
                return { x, y };
            }

            // Calculate control points for curve
            function calculateControlPoints(p1, p2, controlLen) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const angle = Math.atan2(dy, dx);
                
                // Determine control point directions based on connection sides
                let cp1Angle = angle;
                let cp2Angle = angle + Math.PI;
                
                const cp1x = p1.x + Math.cos(cp1Angle) * controlLen;
                const cp1y = p1.y + Math.sin(cp1Angle) * controlLen;
                const cp2x = p2.x + Math.cos(cp2Angle) * controlLen;
                const cp2y = p2.y + Math.sin(cp2Angle) * controlLen;
                
                return { cp1x, cp1y, cp2x, cp2y };
            }

            // Add arrow marker for relationship lines
            function addArrowMarker(svg, id) {
                const defs = svg.querySelector("defs") || (() => {
                    const defsElement = document.createElementNS(SVG_NAMESPACE, "defs");
                    svg.appendChild(defsElement);
                    return defsElement;
                })();
                
                const marker = document.createElementNS(SVG_NAMESPACE, "marker");
                marker.setAttribute("id", id);
                marker.setAttribute("viewBox", "0 0 10 10");
                marker.setAttribute("refX", "9");
                marker.setAttribute("refY", "5");
                marker.setAttribute("markerWidth", "6");
                marker.setAttribute("markerHeight", "6");
                marker.setAttribute("orient", "auto");
                
                const path = document.createElementNS(SVG_NAMESPACE, "path");
                path.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
                path.setAttribute("class", "relationship-arrow");
                
                marker.appendChild(path);
                defs.appendChild(marker);
                
                return marker;
            }

            // Make a table element draggable
            function initDraggable(element, svg, relationships, tableElements) {
                if (!element) return;
                
                let isDragging = false;
                let startX, startY;
                let elementStartX, elementStartY;
                
                element.addEventListener('mousedown', startDrag);
                element.addEventListener('touchstart', startDrag, { passive: false });
                
                function startDrag(e) {
                    if (e.target.closest('.schema-table-body')) return; // Allow text selection inside body
                    
                    e.preventDefault();
                    
                    // Add dragging class for styling
                    element.classList.add('dragging');
                    
                    // Get initial positions
                    isDragging = true;
                    startX = e.clientX || (e.touches && e.touches[0].clientX);
                    startY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    elementStartX = parseFloat(element.style.left) || 0;
                    elementStartY = parseFloat(element.style.top) || 0;
                    
                    // Add global event listeners
                    document.addEventListener('mousemove', onDrag);
                    document.addEventListener('touchmove', onDrag, { passive: false });
                    document.addEventListener('mouseup', stopDrag);
                    document.addEventListener('touchend', stopDrag);
                    
                    // Bring table to front while dragging
                    element.style.zIndex = '100';
                }
                
                function onDrag(e) {
                    if (!isDragging) return;
                    
                    e.preventDefault();
                    
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    // Calculate new position
                    const deltaX = clientX - startX;
                    const deltaY = clientY - startY;
                    
                    element.style.left = (elementStartX + deltaX) + 'px';
                    element.style.top = (elementStartY + deltaY) + 'px';
                    
                    // Update connections
                    drawRelationships(svg, relationships, tableElements);
                }
                
                function stopDrag() {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    element.classList.remove('dragging');
                    element.style.zIndex = '1';
                    
                    // Update connections one final time
                    drawRelationships(svg, relationships, tableElements);
                    
                    // Remove global event listeners
                    document.removeEventListener('mousemove', onDrag);
                    document.removeEventListener('touchmove', onDrag);
                    document.removeEventListener('mouseup', stopDrag);
                    document.removeEventListener('touchend', stopDrag);
                }
            }

            // Initialize pan and zoom functionality
            function initPanZoom(viewport, workspace) {
                if (!viewport || !workspace) return;
                
                let isPanning = false;
                let startPointX, startPointY;
                let startTransformX = 0, startTransformY = 0;
                let currentScale = 1;
                
                // Get transform values
                function getTransform() {
                    const transform = workspace.style.transform;
                    let translateX = 0, translateY = 0, scale = 1;
                    
                    if (transform) {
                        const match = transform.match(/translate\((-?\d+\.?\d*)px,\s*(-?\d+\.?\d*)px\)/);
                        if (match) {
                            translateX = parseFloat(match[1]);
                            translateY = parseFloat(match[2]);
                        }
                        
                        const scaleMatch = transform.match(/scale\((\d+\.?\d*)\)/);
                        if (scaleMatch) {
                            scale = parseFloat(scaleMatch[1]);
                        }
                    }
                    
                    return { translateX, translateY, scale };
                }
                
                // Set transform values
                function setTransform(translateX, translateY, scale) {
                    workspace.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                    currentScale = scale;
                }
                
                // Start pan
                viewport.addEventListener('mousedown', function(e) {
                    // Only handle clicks on the background, not on tables
                    if (e.target !== viewport && e.target !== workspace && !e.target.classList.contains('schema-relationships')) {
                        return;
                    }
                    
                    e.preventDefault();
                    isPanning = true;
                    viewport.classList.add('grabbing');
                    
                    startPointX = e.clientX;
                    startPointY = e.clientY;
                    
                    const { translateX, translateY } = getTransform();
                    startTransformX = translateX;
                    startTransformY = translateY;
                });
                
                // Pan move
                document.addEventListener('mousemove', function(e) {
                    if (!isPanning) return;
                    
                    const deltaX = e.clientX - startPointX;
                    const deltaY = e.clientY - startPointY;
                    
                    setTransform(
                        startTransformX + deltaX,
                        startTransformY + deltaY,
                        currentScale
                    );
                });
                
                // End pan
                document.addEventListener('mouseup', function() {
                    isPanning = false;
                    viewport.classList.remove('grabbing');
                });
                
                // Zoom with wheel
                viewport.addEventListener('wheel', function(e) {
                    e.preventDefault();
                    
                    const { translateX, translateY, scale } = getTransform();
                    const rect = viewport.getBoundingClientRect();
                    
                    // Mouse position relative to viewport
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Mouse position in workspace coordinates (before scaling)
                    const workspaceX = (mouseX - translateX) / scale;
                    const workspaceY = (mouseY - translateY) / scale;
                    
                    // Calculate new scale
                    const scaleDelta = e.deltaY > 0 ? 0.9 : 1.1;
                    const newScale = Math.min(Math.max(scale * scaleDelta, 0.25), 3);
                    
                    // Calculate new translate values to zoom in/out toward mouse position
                    const newTranslateX = mouseX - workspaceX * newScale;
                    const newTranslateY = mouseY - workspaceY * newScale;
                    
                    // Apply transform
                    setTransform(newTranslateX, newTranslateY, newScale);
                }, { passive: false });
            }

            // Initialize zoom control buttons
            function initZoomControls(viewport, workspace) {
                const zoomInBtn = document.getElementById('schema-zoom-in');
                const zoomOutBtn = document.getElementById('schema-zoom-out');
                const resetBtn = document.getElementById('schema-reset');
                
                if (!zoomInBtn || !zoomOutBtn || !resetBtn) return;
                
                // Get current transform
                function getTransform() {
                    const transform = workspace.style.transform;
                    let translateX = 0, translateY = 0, scale = 1;
                    
                    if (transform) {
                        const match = transform.match(/translate\((-?\d+\.?\d*)px,\s*(-?\d+\.?\d*)px\)/);
                        if (match) {
                            translateX = parseFloat(match[1]);
                            translateY = parseFloat(match[2]);
                        }
                        
                        const scaleMatch = transform.match(/scale\((\d+\.?\d*)\)/);
                        if (scaleMatch) {
                            scale = parseFloat(scaleMatch[1]);
                        }
                    }
                    
                    return { translateX, translateY, scale };
                }
                
                // Zoom in button
                zoomInBtn.addEventListener('click', function() {
                    const { translateX, translateY, scale } = getTransform();
                    const newScale = Math.min(scale * 1.2, 3);
                    
                    // Adjust translate values to zoom toward center
                    const viewportRect = viewport.getBoundingClientRect();
                    const viewportCenterX = viewportRect.width / 2;
                    const viewportCenterY = viewportRect.height / 2;
                    
                    // Calculate point to zoom toward (viewport center in workspace coordinates)
                    const focusX = (viewportCenterX - translateX) / scale;
                    const focusY = (viewportCenterY - translateY) / scale;
                    
                    // Calculate new translate values
                    const newTranslateX = viewportCenterX - focusX * newScale;
                    const newTranslateY = viewportCenterY - focusY * newScale;
                    
                    workspace.style.transform = `translate(${newTranslateX}px, ${newTranslateY}px) scale(${newScale})`;
                });
                
                // Zoom out button
                zoomOutBtn.addEventListener('click', function() {
                    const { translateX, translateY, scale } = getTransform();
                    const newScale = Math.max(scale * 0.8, 0.25);
                    
                    // Adjust translate values similar to zoom in
                    const viewportRect = viewport.getBoundingClientRect();
                    const viewportCenterX = viewportRect.width / 2;
                    const viewportCenterY = viewportRect.height / 2;
                    
                    const focusX = (viewportCenterX - translateX) / scale;
                    const focusY = (viewportCenterY - translateY) / scale;
                    
                    const newTranslateX = viewportCenterX - focusX * newScale;
                    const newTranslateY = viewportCenterY - focusY * newScale;
                    
                    workspace.style.transform = `translate(${newTranslateX}px, ${newTranslateY}px) scale(${newScale})`;
                });
                
                // Reset view button
                resetBtn.addEventListener('click', function() {
                    centerWorkspace(viewport, workspace);
                });
            }

            // Center workspace in viewport
            function centerWorkspace(viewport, workspace) {
                if (!viewport || !workspace) return;
                
                // Calculate size differences
                const viewportWidth = viewport.clientWidth;
                const viewportHeight = viewport.clientHeight;
                const workspaceWidth = parseFloat(workspace.style.width);
                const workspaceHeight = parseFloat(workspace.style.height);
                
                // Calculate scale to fit (with some margin)
                const margin = 40;
                const scaleX = (viewportWidth - margin) / workspaceWidth;
                const scaleY = (viewportHeight - margin) / workspaceHeight;
                const scale = Math.min(scaleX, scaleY, 0.8); // Cap scale
                
                // Calculate centering translation
                const translateX = (viewportWidth - workspaceWidth * scale) / 2;
                const translateY = (viewportHeight - workspaceHeight * scale) / 2;
                
                // Apply transform
                workspace.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }

            // Initialize enhanced schema visualization
            visualizeSchema();

            // Format result data as HTML table if available
            formatResultsAsTable();

            // Initialize notes functionality
            initNotesFeature();

            // Initialize editor functionality
            initEditorFeatures();

            // Adjust right column layout if results are present
             const rightColumn = document.querySelector('.col-lg-7 > .d-flex');
             if (rightColumn && document.querySelector('.result-container, .alert-danger')) {
                 // If results/error exist, make editor card non-growable
                 const editorCard = rightColumn.querySelector('.card:first-child');
                 if(editorCard) editorCard.classList.replace('flex-grow-1', 'flex-grow-0');
             }
        });

        // Define constants at a higher scope so they're accessible to all functions
        const TABLE_WIDTH = 260; // Width of table element
        const TABLE_HEIGHT = 150; // Estimated average height
        const HORIZONTAL_SPACING = 30;
        const VERTICAL_SPACING = 50;
        const SVG_NAMESPACE = "http://www.w3.org/2000/svg"; // Define SVG namespace here

        // --- 1. Schema Visualization (Enhanced with Auto-Layout) ---
        
        function parseSchemaFromSQL(sql) {
            const tables = [];
            if (!sql) return tables;

            // Regex to capture CREATE TABLE statements, including quoted names and the definition body
            const tablePattern = /CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(?:[\w`"\[\]]+\.)?([\w`"\[\]]+)\s*\(([\s\S]*?)\)\s*;/gi;
            let tableMatch;

            while ((tableMatch = tablePattern.exec(sql)) !== null) {
                const tableName = tableMatch[1].replace(/[`"\[\]]/g, ''); // Clean table name
                const definitionBody = tableMatch[2]; // Content within (...)
                const columns = [];
                let tablePrimaryKeys = []; // Store PKs defined separately at table level
                let foreignKeys = []; // Store FK definitions { column, referencesTable, referencesColumn }

                // Split definition body into individual lines (handles constraints better)
                const lines = definitionBody.split(/,\s*(?![^()]*\))/).map(line => line.trim()).filter(line => line);

                lines.forEach(line => {
                    const upperLine = line.toUpperCase();

                    // --- Primary Key Parsing ---
                    if (upperLine.startsWith('PRIMARY KEY')) {
                        const pkMatch = line.match(/\((.*?)\)/);
                        if (pkMatch && pkMatch[1]) {
                            tablePrimaryKeys = pkMatch[1].split(',').map(c => c.trim().replace(/[`"\[\]]/g, ''));
                        }
                        return; // This line is a constraint, not a column
                    }
                    if (upperLine.startsWith('CONSTRAINT') && upperLine.includes('PRIMARY KEY')) {
                        const pkMatch = line.match(/PRIMARY\s+KEY\s*\((.*?)\)/i);
                        if (pkMatch && pkMatch[1]) {
                            tablePrimaryKeys = pkMatch[1].split(',').map(c => c.trim().replace(/[`"\[\]]/g, ''));
                        }
                        return;
                    }

                    // --- Foreign Key Parsing ---
                    if (upperLine.startsWith('FOREIGN KEY') || (upperLine.startsWith('CONSTRAINT') && upperLine.includes('FOREIGN KEY'))) {
                        const fkMatch = line.match(/FOREIGN\s+KEY\s*\(([\w`"\[\], ]+)\)\s+REFERENCES\s+([\w`"\[\]]+)(?:\s*\(([\w`"\[\], ]+)\))?/i);
                        if (fkMatch) {
                            const fkColumns = fkMatch[1].split(',').map(c => c.trim().replace(/[`"\[\]]/g, ''));
                            const refTable = fkMatch[2].replace(/[`"\[\]]/g, '');
                            // Referenced columns might be omitted if they match PK of referenced table
                            const refColumns = fkMatch[3] ? fkMatch[3].split(',').map(c => c.trim().replace(/[`"\[\]]/g, '')) : [];

                            fkColumns.forEach((fkCol, index) => {
                                foreignKeys.push({
                                    column: fkCol,
                                    referencesTable: refTable,
                                    // If reference columns are specified, use them; otherwise assume they match the FK column name
                                    referencesColumn: refColumns.length > index ? refColumns[index] : fkCol
                                });
                            });
                        }
                        return; // Constraint line
                    }

                    // --- Column Parsing ---
                    // Skip other constraints
                    if (upperLine.startsWith('CONSTRAINT') || upperLine.startsWith('UNIQUE') || upperLine.startsWith('CHECK')) {
                        return;
                    }

                    // Parse column definition
                    const parts = line.split(/\s+/);
                    if (parts.length >= 2) {
                        const columnName = parts[0].replace(/[`"\[\]]/g, '');
                        let columnType = parts[1]; // Basic type
                        
                        // Handle complex types with parentheses like VARCHAR(50)
                        if (parts.length > 2 && parts[2].startsWith('(')) {
                            columnType += ' ' + parts.slice(2).join(' ').split(' ')[0];
                        }
                        
                        const isInlinePK = upperLine.includes(' PRIMARY KEY');
                        const hasInlineFKRef = upperLine.includes(' REFERENCES ');

                        columns.push({
                            name: columnName,
                            type: columnType.toUpperCase(),
                            isPrimaryKey: isInlinePK, // Detect only INLINE PK here
                            isForeignKey: hasInlineFKRef, // Detect only INLINE FK here (will be confirmed later)
                            // Store inline reference info if present
                            inlineRefTable: hasInlineFKRef ? line.match(/REFERENCES\s+([\w`"\[\]]+)/i)?.[1]?.replace(/[`"\[\]]/g, '') : null,
                            inlineRefCol: hasInlineFKRef ? line.match(/REFERENCES\s+[\w`"\[\]]+\s*\(([\w`"\[\]]+)\)/i)?.[1]?.replace(/[`"\[\]]/g, '') : null
                        });
                    }
                });

                // --- Post-processing ---
                // Apply table-level PKs
                columns.forEach(column => {
                    if (tablePrimaryKeys.includes(column.name)) {
                        column.isPrimaryKey = true;
                    }
                });

                // Apply table-level FKs
                foreignKeys.forEach(fk => {
                    const col = columns.find(c => c.name === fk.column);
                    if (col) {
                        col.isForeignKey = true;
                        col.referencesTable = fk.referencesTable;
                        col.referencesColumn = fk.referencesColumn;
                    }
                });

                // Apply inline FKs (if not already marked by table-level constraint)
                columns.forEach(col => {
                    if (col.isForeignKey && col.inlineRefTable && !col.referencesTable) {
                        col.referencesTable = col.inlineRefTable;
                        col.referencesColumn = col.inlineRefCol ?? col.name;
                    }
                });

                tables.push({
                    name: tableName,
                    columns: columns
                });
            }

            return tables;
        }

        // Auto-layout calculation for tables
        function calculateTableLayout(tables, containerWidth) {
            // Determine relationships between tables
            const relationships = [];
            const tableMap = {};
            
            // Create a lookup map of tables
            tables.forEach(table => {
                tableMap[table.name] = table;
            });
            
            // Find all relationships
            tables.forEach(table => {
                table.columns.forEach(column => {
                    if (column.isForeignKey && column.referencesTable) {
                        relationships.push({
                            from: table.name,
                            to: column.referencesTable,
                            fromColumn: column.name,
                            toColumn: column.referencesColumn
                        });
                    }
                });
            });
            
            // Group tables by their relationship depth
            const tableDepths = {};
            const processed = new Set();
            const rootTables = new Set(tables.map(t => t.name));
            
            // Remove tables that are referenced by others from root tables
            relationships.forEach(rel => {
                rootTables.delete(rel.to);
            });
            
            // If no root tables (circular references), just pick the first table
            if (rootTables.size === 0 && tables.length > 0) {
                rootTables.add(tables[0].name);
            }
            
            // Assign depths using breadth-first traversal
            let currentDepth = 0;
            let currentLevel = [...rootTables];
            
            while (currentLevel.length > 0) {
                const nextLevel = [];
                
                currentLevel.forEach(tableName => {
                    if (!processed.has(tableName)) {
                        tableDepths[tableName] = currentDepth;
                        processed.add(tableName);
                        
                        // Find all tables this one references
                        relationships.forEach(rel => {
                            if (rel.from === tableName && !processed.has(rel.to)) {
                                nextLevel.push(rel.to);
                            }
                        });
                    }
                });
                
                currentDepth++;
                currentLevel = nextLevel;
            }
            
            // Handle any remaining tables (circular references)
            tables.forEach(table => {
                if (!processed.has(table.name)) {
                    tableDepths[table.name] = currentDepth;
                    currentDepth++;
                }
            });
            
            // Group tables by depth
            const tablesByDepth = {};
            Object.entries(tableDepths).forEach(([tableName, depth]) => {
                if (!tablesByDepth[depth]) tablesByDepth[depth] = [];
                tablesByDepth[depth].push(tableName);
            });
            
            // Calculate positions
            const positions = {};
            
            const maxTablesPerRow = Math.max(1, Math.floor((containerWidth - HORIZONTAL_SPACING) / (TABLE_WIDTH + HORIZONTAL_SPACING)));
            let yOffset = VERTICAL_SPACING;
            
            Object.entries(tablesByDepth).forEach(([depth, tableNames]) => {
                let xOffset = HORIZONTAL_SPACING;
                let maxHeight = 0;
                
                // Calculate how many tables will fit per row
                const tablesInCurrentRow = Math.min(tableNames.length, maxTablesPerRow);
                const horizontalGap = (containerWidth - (tablesInCurrentRow * TABLE_WIDTH)) / (tablesInCurrentRow + 1);
                
                tableNames.forEach((tableName, index) => {
                    const table = tableMap[tableName];
                    const rowIndex = Math.floor(index / maxTablesPerRow);
                    const colIndex = index % maxTablesPerRow;
                    
                    const x = horizontalGap + colIndex * (TABLE_WIDTH + horizontalGap);
                    const y = yOffset + rowIndex * (TABLE_HEIGHT + VERTICAL_SPACING);
                    
                    positions[tableName] = { x, y };
                    
                    // Track max height for this row
                    const estimatedHeight = 50 + (table.columns.length * 30); // Header + columns
                    maxHeight = Math.max(maxHeight, estimatedHeight);
                });
                
                // Update yOffset for next depth level
                yOffset += Math.ceil(tableNames.length / maxTablesPerRow) * (maxHeight + VERTICAL_SPACING);
            });
            
            return { positions, relationships };
        }

        // Format SQL query results into an HTML table
function formatResultsAsTable() {
    const rawResults = document.getElementById('raw-results');
    const formattedResultsContainer = document.getElementById('formatted-results');
    
    if (!rawResults || !formattedResultsContainer) return;
    
    const rawText = rawResults.textContent.trim();
    if (!rawText) {
        formattedResultsContainer.innerHTML = '<div class="text-center text-muted p-3">No results to display</div>';
        return;
    }
    
    try {
        // Split into lines and parse
        const lines = rawText.split('\n');
        if (lines.length < 3) {
            formattedResultsContainer.innerHTML = '<div class="text-center text-muted p-3">No results or invalid format</div>';
            return;
        }
        
        // Get header row
        const headerCols = lines[0].split('|').map(col => col.trim());
        
        // Create table HTML
        let tableHtml = '<table class="query-results-table">';
        
        // Add header
        tableHtml += '<thead><tr>';
        headerCols.forEach(col => {
            tableHtml += `<th>${col}</th>`;
        });
        tableHtml += '</tr></thead>';
        
        // Add body (skip header row and separator line)
        tableHtml += '<tbody>';
        for (let i = 2; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue; // Skip empty lines
            
            const rowCells = line.split('|').map(cell => cell.trim());
            tableHtml += '<tr>';
            rowCells.forEach(cell => {
                const cellContent = cell === 'NULL' ? 
                    '<span class="text-muted">NULL</span>' : 
                    cell;
                tableHtml += `<td>${cellContent}</td>`;
            });
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        
        formattedResultsContainer.innerHTML = tableHtml;
    } catch (err) {
        console.error('Error formatting results:', err);
        formattedResultsContainer.innerHTML = `
            <div class="alert alert-warning">
                <i class="bi bi-exclamation-triangle-fill me-2"></i> 
                Could not format results. Raw output shown below:
            </div>
            <pre class="bg-light p-3 rounded"><code>${rawText}</code></pre>
        `;
    }
}

        // --- 2. Notes Feature ---
        function initNotesFeature() {
            const notesTextarea = document.getElementById('userNotes');
            const savedIndicator = document.getElementById('notes-saved');

            if (!notesTextarea) return;

            // Load saved notes from localStorage
            const savedNotes = localStorage.getItem('userNotes');
            if (savedNotes) {
                notesTextarea.value = savedNotes;
            }

            // Save notes to localStorage on input
            notesTextarea.addEventListener('input', function() {
                localStorage.setItem('userNotes', notesTextarea.value);
                savedIndicator.classList.add('visible');
            });

            // Clear notes button
            document.getElementById('clearNotes').addEventListener('click', function() {
                notesTextarea.value = '';
                localStorage.removeItem('userNotes');
                savedIndicator.classList.remove('visible');
            });
        }

        // --- 3. SQL Editor Features ---
        function initEditorFeatures() {
            const sqlQueryArea = document.getElementById('sqlQueryArea');
            const autoFormatCheck = document.getElementById('autoFormatCheck');
            
            if (!sqlQueryArea) return;
            
            // Replace textarea with CodeMirror
            const editor = CodeMirror.fromTextArea(sqlQueryArea, {
                mode: 'text/x-sql',
                theme: 'cute-sql',
                lineNumbers: true,
                lineWrapping: true,
                matchBrackets: true,
                indentWithTabs: false,
                tabSize: 2,
                indentUnit: 2,
                viewportMargin: Infinity,
                placeholder: "-- Enter your SQL query here...\nSELECT CustomerID, FirstName, Email FROM Customers WHERE RegistrationDate > '2023-01-01';",
                extraKeys: {
                    "Ctrl-Space": "autocomplete"
                }
            });
            
            // Resize editor based on content
            const updateEditorHeight = () => {
                const height = Math.max(150, Math.min(500, editor.doc.height + 30));
                editor.setSize(null, height);
            };
            
            editor.on("change", () => {
                updateEditorHeight();
                editor.save(); // Sync with textarea
            });
            
            // Initialize height
            setTimeout(updateEditorHeight, 100);
            
            // Add handler for template buttons
            document.querySelectorAll('.template-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const template = this.getAttribute('data-template');
                    if (template) {
                        const cursor = editor.getCursor();
                        editor.replaceRange(template, cursor);
                        editor.focus();
                    }
                });
            });
            
            // Fullscreen toggle
            document.getElementById('toggle-fullscreen').addEventListener('click', function() {
                document.body.classList.toggle('editor-fullscreen-mode');
                const card = this.closest('.card');
                if (card) card.classList.toggle('editor-fullscreen');
                setTimeout(() => {
                    editor.refresh();
                    updateEditorHeight();
                }, 100);
            });
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize syntax highlighting for SQL blocks
            document.querySelectorAll('pre code.language-sql').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Format result data as HTML table if available
            formatResultsAsTable();
            
            // Initialize notes functionality
            initNotesFeature();
            
            // Enhanced schema visualization
            visualizeSchema();
            
            // Initialize editor with syntax highlighting
            initEditorFeatures();
            
            // Adjust right column layout if results are present
            const rightColumn = document.querySelector('.col-lg-7 > .d-flex');
            if (rightColumn && document.querySelector('.result-container, .alert-danger')) {
                const editorCard = rightColumn.querySelector('.card:first-child');
                if(editorCard) editorCard.classList.replace('flex-grow-1', 'flex-grow-0');
            }
        });
    </script>
}